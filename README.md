# SKiPOD
CS MSU course


# Постановка задачи
•	Реализовать параллельную версию алгоритма RedBlack2D с использованием технологий OpenMP.

•	Исследовать масштабируемость полученной параллельной программы: построить графики зависимости времени исполнения от числа ядер/процессоров для различного объёма входных данных.

# Оптимизация

## Предоставленный алгоритм:

Было замечено, что исходная последовательная программа написана неэффективно. Были внесены следующие изменения, которые также повлияли на время работы:

•	Неэффективный проход по двойному массиву. Известно, что в языке Си массивы располагаются в памяти по строкам (сначала идут элементы первой строки, затем элементы второй строки и т.д.). Для последовательного доступа к памяти циклы были поменяны местами, что привело к ускорению.

•	Лишнее условие при инициализации массива A. Случаи, описанные в условиях, можно не рассматривать, так как глобальные массивы инициализируются нулями при создании.

•	В функции relax можно идти сразу по нужным нам элементам. Так мы обойдемся без лишнего условия, заодно снизим количество итераций.

## Распараллеливание 
Программа была распаралелена класссичиским средствами, предоставляемыми библиотекой OpenMP:

•	Наибольший выигрыш в производительности дает распараллеливание relax, так как эта функция вызывается наибольшее количество раз. Были распаралелены оба внешних цикла. В первом цикле есть разделяемая переменная eps. Эксперементы показали, что при использовании критической секции, время работы росло с увелечинением количества нитей, то есть данный подход неэффективен. Было решено использовать прагму reduction (max:eps).

•	Также был распараллелены функции init и verify.

# Результаты 

Работа задачи рассмотрена на суперкомпьютере Polus с различным числом нитей (1...160) и различными размерами матрицы (514...8194). Каждое измерение проводилось 3 раза. Явные выбросы не учитывались, брался средний результат среди оставшихся.

Таблица #ToDO
  

3D график #ToDO
 
 
 

# Анализ результатов

Анализируя полученные замеры, можно заметить, что при количестве ядер 1, 2, 4, 8 можем наблюдать почти линейную зависимость от количества ядер. Дальнейшее распараллеливание постепенно приводит на плато, а в дальнейшем и к ухудшению показателей. Это происходит из-за роста накладных расходов. 

# Выводы

Были изучена схема работы с суперкомпьютером Polus и получены навыки использования технологии параллельного программирования OpenMP. Реализована параллельная версия алгоритма RedBlack2D с использованием данной технологии. Получен 50 кратный выигрыш в производительности на матрице наибольшего размера (8194). Визуализация результатов изображена на графиках.
В дальнейшем планируется реализовать алгоритм с использованием MPI, сделать полноценные выводы и провести сравнительную аналитику. 
